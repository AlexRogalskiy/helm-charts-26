### Image
image:
  image: kestra/kestra
  tag: latest-full
  pullPolicy: IfNotPresent

imagePullSecrets: []


### Configurations for deployments
configuration: {}


### Secrets for deployments
secrets: {}


### configuration files
configurationPath:


### Kestra executable
executable: /app/kestra


### Deployments
deployments:
  webserver:
    enabled: true
    kind: Deployment
    replicaCount: 1
    command: "server webserver"
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    strategy: {}
    podSecurityContext: {}
    securityContext: {}
    terminationGracePeriodSeconds: 30
    autoscaler:
      enabled: false
      minReplicas: 1
      maxReplicas: 3
      extra: {}
      metrics: []
      #  - type: Resource
      #    resource:
      #      name: cpu
      #      target:
      #        type: Utilization
      #        averageUtilization: 50
      #  - type: Resource
      #    resource:
      #      name: memory
      #      target:
      #        type: AverageValue
      #        averageValue: 100Mi

  executor:
    enabled: true
    kind: Deployment
    command: "server executor"

  indexer:
    enabled: true
    kind: Deployment
    command: "server indexer"

  scheduler:
    enabled: true
    kind: Deployment
    command: "server scheduler"

  worker:
    enabled: true
    kind: Deployment
    command: "server worker --thread=128"
    terminationGracePeriodSeconds: 60

  standalone:
    enabled: false
    kind: Deployment
    command: "server standalone"
    terminationGracePeriodSeconds: 60


# for io.kestra.core.tasks.scripts.Bash task, attach a docker dind container in order to isolate in a container
# every command launch
dind:
  enabled: true
  image:
    image: docker
    tag: dind-rootless
    pullPolicy: IfNotPresent
  socketPath: /dind/
  tmpPath: /tmp/
  resources: {}
  args:
    - --log-level=fatal
    - --group=1000
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000


### Kafka
kafka:
  enabled: false

### ElasticSearch
elasticsearch:
  enabled: false
  clusterName: "es-kestra"

  esConfig:
    elasticsearch.yml: |
      xpack:
        security:
          enabled: false

  antiAffinity: "soft"

  roles:
    ml: "false"


### Minio
minio:
  enabled: false
  rootUser: please-change-me
  rootPassword: its-not-a-secret
  mode: standalone
  persistence:
    size: 8Gi
  buckets:
    - name: kestra
      policy: none
      purge: false


# postgresql configures the backing database
# NOTE: the variables names must remain as is to match the
# bitnami subchart even if the bitnami subchart is not being
# used, these variables are used to create the connection
# string
postgresql:
  postgresqlDatabase: kestra

  # postgresqlUsername defines the username to authenticate
  # with.
  # NOTE: If you are using Azure, this will include an '@'
  # which must be encoded as '%40' for the connection string
  # to work with both Hasura, the GraphQL server, and the
  # Alembic migration manager
  postgresqlUsername: kestra

  # existingSecret configures which secret should be referenced
  # for access to the database. If null and `useSubChart` is
  # enabled, the secret will be generated. If using an external
  # postgres service, this value should be set to the name of
  # an existing Kubernetes secret. This secret must contain
  # a key-value pair where the key is `postgresql-password `
  # and the value is your password. For more information,
  # see the "Database" section of the README.
  existingSecret: null

  # postgresqlPassword sets the password to be used if
  # `existingSecret` is not set. This is the password for
  # `postgresqlUsername` and will be set within the secret at
  # the key `postgresql-password`. This argument is only relevant
  # when using the Postgres database included in the chart.
  # For an external postgres connection, you must create
  # and use `existingSecret` instead of `postgresqlPassword`.
  # postgresqlPassword: use-a-strong-password

  # servicePort configures the port that the database should be
  # accessed at
  servicePort: 5432

  # externalHostname defines the address to contact an externally
  # managed postgres database instance at. This is not required if
  # `internalPostgres` is `true`
  externalHostname: ""

  # useSubChart determines if a this chart should deploy a
  # user-manager postgres database or use an externally managed
  # postgres instance. If `useSubChart` is `true`, the
  # bitnami/postgresql subchart will be deployed
  enabled: true


  persistence:
    enabled: false
    size: 8Gi

  initdbUser: postgres

  initdbScripts:
    init.sql: |
      SET TIME ZONE 'UTC';

### Services
service:
  type: ClusterIP
  port: 8080
  annotations: {}


### Ingress
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local


### Global Deployement
nameOverride: ""
serviceAccountName: ""


### Annotations for deployments
annotations: {}
podAnnotations: {}
initContainers: []

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

terminationGracePeriodSeconds: 30

nodeSelector: {}

tolerations: []

affinity: {}

extraVolumeMounts: []

extraVolumes: []

extraEnv: []

podSecurityContext: {}
# fsGroup: 2000

securityContext:
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000

### Readiness / Liveness probe config.
### ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
readinessProbe:
  enabled: true
  path: /health
  port: management
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3
  httpGetExtra: {}

livenessProbe:
  enabled: true
  path: /health
  port: management
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3
  httpGetExtra: {}
